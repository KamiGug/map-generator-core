version: "3"

vars:
  BUILD_DIR: "build"
  EXE_NAME:
    sh: |
      RAW=$(grep "OUTPUT_NAME" CMakeLists.txt | tail -n1 | sed -E 's/.*OUTPUT_NAME\s+//; s/[")]//g; s/\)//g; s/\s+$//')
      if [[ "$RAW" =~ \$\{([^}]+)\} ]]; then
        VAR_NAME="${BASH_REMATCH[1]}"
        VALUE=$(grep -E "set\s*\(\s*$VAR_NAME" CMakeLists.txt | head -n1 | sed -E "s/.*$VAR_NAME\s+//; s/[)\"]//g; s/\s+$//")
        if [ -z "$VALUE" ] && [ "$VAR_NAME" = "PROJECT_NAME" ]; then
          VALUE=$(grep -i "project(" CMakeLists.txt | head -n1 | sed -E 's/project\s*\(\s*([[:alnum:]_]+).*/\1/')
        fi
        echo "$RAW" | sed "s/\${$VAR_NAME}/$VALUE/g"
      else
        echo "$RAW"
      fi | tr -d '\n\r '
tasks:
  default:
    cmds:
      - task --list

  install:
    desc: Fresh after pull configuration.
    deps:
      - task: dependencies
    cmds:
      - lefthook install

  dependencies:
    desc: Check if all the dependencies are present.
    cmds:
      - |
        tools="lefthook typos clang-format cmake make"
        for tool in $tools; do
            command -v $tool >/dev/null || echo "missing $tool"
        done;

  nix:
    desc: Enter the nix dev shell.
    cmds:
      - |
        nix --extra-experimental-features nix-command --extra-experimental-features flakes develop

  nix-docker:
    desc: Enter a docker container with nix.
    cmds:
      - |
        docker run -it --rm \
          -v "$PWD:$PWD" -w "$PWD" \
          -e NIX_CONFIG="extra-experimental-features = nix-command flakes" \
          -e HOST_UID=$(id -u) \
          -e HOST_GID=$(id -g) \
          -e GIT_AUTHOR_NAME="$(git config user.name)" \
          -e GIT_AUTHOR_EMAIL="$(git config user.email)" \
          -e GIT_COMMITTER_NAME="$(git config user.name)" \
          -e GIT_COMMITTER_EMAIL="$(git config user.email)" \
          nixos/nix \
          sh -c "git config --global --add safe.directory '*' && \
            trap 'chown -R \$HOST_UID:\$HOST_GID .' EXIT && \
            nix develop"

  test:
    desc: Run the project tests using ctest
    Usage: task test -- [<test_name_regex>]
    cmds:
      - |
        TEST_NAME_REGEX="";
        if [ -n "{{.CLI_ARGS}}" ]; then
          TEST_NAME_REGEX="-R {{.CLI_ARGS}}"
        fi
        ctest --test-dir {{.BUILD_DIR}} --output-on-failure $TEST_NAME_REGEX

  build:
    desc: Configure and build the project.
    Usage: task build -- [cli] [prod] [clean]
    cmds:
      - |
        CLI_VAL="OFF"
        TEST_VAL="ON"
        BUILD_TYPE="Debug"
        CLEAN="OFF"

        # Parse CLI_ARGS for our custom flags
        for arg in {{.CLI_ARGS}}; do
          case $arg in
            cli)  CLI_VAL="ON" ;;
            prod) TEST_VAL="OFF"; BUILD_TYPE="Release" ;;
            clean) CLEAN="ON" ;;
          esac
        done

        if [ "$CLEAN" = "ON" ]; then
          rm -fr build .cache;
        fi

        cmake -S . -B {{.BUILD_DIR}} \
            -DCMAKE_BUILD_TYPE=${BUILD_TYPE} \
            -DBUILD_CLI=${CLI_VAL} \
            -DBUILD_TESTING=${TEST_VAL}
        cmake --build {{.BUILD_DIR}} --parallel
        rm -f compile_commands.json
        cp {{.BUILD_DIR}}/compile_commands.json compile_commands.json

  run:
    desc: Run the generated mapgen binary
    cmds:
      - "{{.BUILD_DIR}}/{{.EXE_NAME}} {{.CLI_ARGS}}"

  commit-msg:
    desc: Validate commit message format (used by git hooks)
    cmds:
      - |
        MSG_FILE="{{.CLI_ARGS}}"
        [ -f "$MSG_FILE" ] || { echo "Usage: task commit-msg -- <file>"; exit 1; }
        TITLE=$(head -n1 "$MSG_FILE")
        [[ ${#TITLE} -le 100 ]] || { echo "Title too long"; exit 1; }
        echo "$TITLE" | grep -Eq '^(feat|fix|docs|style|refactor|perf|test|build|ci|chore)(\(.*\))?(!)?: .+$' || {
          echo "Invalid format. Expected: type(scope): message"
          exit 1
        }

  lint:
    desc: Lint staged files
    parallel: true
    deps:
      - task: _format_action
        vars:
          {
            CMD: "git diff --name-only --cached --diff-filter=ACMR",
            OPTS: "--dry-run --Werror",
          }
      - task: _header_action
        vars: { CMD: "git diff --name-only --cached --diff-filter=ACMR" }
      - task: _typo_action
        vars: { CMD: "git diff --name-only --cached --diff-filter=ACMR" }

  lint-fix:
    desc: Fix staged files
    deps:
      - task: _format_action
        vars:
          {
            CMD: "git diff --name-only --cached --diff-filter=ACMR",
            OPTS: "-i",
          }
      - task: _typo_action
        vars:
          {
            CMD: "git diff --name-only --cached --diff-filter=ACMR",
            TYPO_OPTS: "-w",
          }

  lint-all:
    desc: Lint all tracked files
    parallel: true
    deps:
      - task: _format_action
        vars: { CMD: "git ls-files", OPTS: "--dry-run --Werror" }
      - task: _header_action
        vars: { CMD: "git ls-files" }
      - task: _typo_action
        vars: { CMD: "git ls-files" }

  lint-fix-all:
    desc: Fix all tracked files
    deps:
      - task: _format_action
        vars: { CMD: "git ls-files", OPTS: "-i" }
      - task: _typo_action
        vars: { CMD: "git ls-files", TYPO_OPTS: "-w" }

  _format_action:
    internal: true
    cmds:
      - |
        {{.CMD}} -- '*.cpp' '*.cc' '*.c' '*.h' '*.hpp' | \
        xargs -I {} clang-format {{.OPTS}} "{}"

  _typo_action:
    internal: true
    cmds:
      - |
        # typos can read a list of files from stdin with '-'
        {{.CMD}} | typos {{.TYPO_OPTS}} -

  _header_action:
    internal: true
    cmds:
      - |
        {{.CMD}} -- '*.h' '*.hpp' | while read -r file; do
          [ -f "$file" ] || continue
          first=$(grep -vE '^\s*(//|$)' "$file" | head -n1)
          if [[ ! "$first" =~ ^#ifndef ]] && [[ ! "$first" =~ ^#pragma\ once ]]; then
             echo "❌ $file: Missing guard/pragma" && exit 1
          fi
          last=$(grep -vE '^\s*$' "$file" | tail -n1)
          if [[ "$first" =~ ^#ifndef ]] && [[ ! "$last" =~ ^#endif ]]; then
             echo "❌ $file: Missing #endif" && exit 1
          fi
        done
