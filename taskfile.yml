version: "3"

tasks:
  default:
    cmds:
      - task --list

  install:
    desc: Fresh after pull configuration.
    deps: 
      - task: dependencies
    cmds:
      - lefthook install

  dependencies:
    desc: Check if all the dependencies are present.
    cmds:
      - |
        command -v lefthook >/dev/null || echo "missing lefthook"
      - |
        command -v typos >/dev/null || echo "missing typos"
      - |
        command -v clang-format >/dev/null || echo "missing clang-format, try installing llvm"
      - |
        command -v cmake >/dev/null || echo "missing CMAKE"
      - |
        command -v make >/dev/null || echo "missing MAKE"


  nix:
    desc: Enter the nix dev shell.
    cmds:
      - |
        nix --extra-experimental-features nix-command --extra-experimental-features flakes develop
  

  build:
    desc: Configure and build the project. 
    Usage: task build -- [cli] [prod] [clean]
    cmds: 
      - |
        CLI_VAL="OFF"
        TEST_VAL="ON"
        DEBUG_VAL="ON"
        CLEAN="OFF"

        # Parse CLI_ARGS for our custom flags
        for arg in {{.CLI_ARGS}}; do
          case $arg in
            cli)  CLI_VAL="ON" ;;
            prod) TEST_VAL="OFF"; DEBUG_VAL="OFF" ;;
            clean) CLEAN="ON" ;;
          esac
        done

        if [ "$CLEAN" = "ON" ]; then 
          rm -fr build .cache;
        fi
      
        cmake -S . -B build \
            -DCMAKE_BUILD_TYPE=${DEBUG_VAL} \
            -DBUILD_CLI=${CLI_VAL} \
            -DBUILD_TESTING=${TEST_VAL}
        cmake --build build --parallel
        rm -f compile_commands.json
        cp build/compile_commands.json compile_commands.json

  run:
    deps: [build]
    desc: Run the generated mapgen binary
    cmds:
      - ./build/mapgen

  commit-msg:
    desc: Validate commit message format (used by git hooks)
    cmds:
      - |  
        MSG_FILE="{{.CLI_ARGS}}"
        [ -f "$MSG_FILE" ] || { echo "Usage: task commit-msg -- <file>"; exit 1; }
        TITLE=$(head -n1 "$MSG_FILE")
        [[ ${#TITLE} -le 100 ]] || { echo "❌ Title too long"; exit 1; }
        echo "$TITLE" | grep -Eq '^(feat|fix|docs|style|refactor|perf|test|build|ci|chore)(\(.*\))?(!)?: .+$' || {
          echo "❌ Invalid format. Expected: type(scope): message"
          exit 1
        }

  lint:
    desc: Lint staged files
    parallel: true
    deps:
      - task: _format_action
        vars: { CMD: "git diff --name-only --cached --diff-filter=ACMR", OPTS: "--dry-run --Werror" }
      - task: _header_action
        vars: { CMD: "git diff --name-only --cached --diff-filter=ACMR" }
      - task: _typo_action
        vars: { CMD: "git diff --name-only --cached --diff-filter=ACMR" }

  lint-fix:
    desc: Fix staged files
    deps:
      - task: _format_action
        vars: { CMD: "git diff --name-only --cached --diff-filter=ACMR", OPTS: "-i" }
      - task: _typo_action
        vars: { CMD: "git diff --name-only --cached --diff-filter=ACMR", TYPO_OPTS: "-w" }

  lint-all:
    desc: Lint all tracked files
    parallel: true
    deps:
      - task: _format_action
        vars: { CMD: "git ls-files", OPTS: "--dry-run --Werror" }
      - task: _header_action
        vars: { CMD: "git ls-files" }
      - task: _typo_action
        vars: { CMD: "git ls-files" }

  lint-fix-all:
    desc: Fix all tracked files
    deps:
      - task: _format_action
        vars: { CMD: "git ls-files", OPTS: "-i" }
      - task: _typo_action
        vars: { CMD: "git ls-files", TYPO_OPTS: "-w" }

  _format_action:
    internal: true
    cmds:
      - |
        {{.CMD}} -- '*.cpp' '*.cc' '*.c' '*.h' '*.hpp' | \
        xargs -I {} clang-format {{.OPTS}} "{}"

  _typo_action:
    internal: true
    cmds:
      - |
        # typos can read a list of files from stdin with '-'
        {{.CMD}} | typos {{.TYPO_OPTS}} -

  _header_action:
    internal: true
    cmds:
      - |
        {{.CMD}} -- '*.h' '*.hpp' | while read -r file; do
          [ -f "$file" ] || continue
          first=$(grep -vE '^\s*(//|$)' "$file" | head -n1)
          if [[ ! "$first" =~ ^#ifndef ]] && [[ ! "$first" =~ ^#pragma\ once ]]; then
             echo "❌ $file: Missing guard/pragma" && exit 1
          fi
          last=$(grep -vE '^\s*$' "$file" | tail -n1)
          if [[ "$first" =~ ^#ifndef ]] && [[ ! "$last" =~ ^#endif ]]; then
             echo "❌ $file: Missing #endif" && exit 1
          fi
        done

